[{"content":"Okhttp发送请求卡住问题解决 我们有一个消费者组是发送请求用的,一直有一个问题是有时候会堆积,然后就不消费了,重启后就恢复了.\u0026hellip;\n于是我让运维加了一个脚本,在堆积的时候触发这个脚本(dump出来文件),然后重启消费者组,先这样解决,等上班了再检查dump的文件\n于是乎就有了下边这个图里的内容,发现其他线程都在wait,只有一个在runing,然后看到堆栈信息卡在了这个方法,点进去查看这个是一个native方法,这个目前看是做不了什么了\n突然想到我们都是ipv4,这个是调用的ipv6的类,于是去查了资料发现可以在启动项上加-Djava.net.preferIPv4Stack=true{.language-plaintext .highlighter-rouge}来使用ipv4类,加上之后跑了一星期没有再出现之前的问题,问题解决\n","date":"2024-04-18T20:16:00+08:00","permalink":"https://chenchenfang.github.io/p/okhttp%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","title":"Okhttp发送请求卡住问题解决"},{"content":"IDEA 2024.1 版本提高流畅度方法 {#idea-2024.1-%E7%89%88%E6%9C%AC%E6%8F%90%E9%AB%98%E6%B5%81%E7%95%85%E5%BA%A6%E6%96%B9%E6%B3%95 style=\u0026quot;\u0026quot;} 今天看IDEA出了2024.1 ,本着尝鲜的想法安装了\n正好前段时间测试了JDK21的分代ZGC,可以说基本就没有stop the world,这不都安装了新版本了,顺便修改一下运行的JDK版本和垃圾回收机制\n按两下shift ,然后输入runtime,选择红框这个\n然后会提示重启IDEA,重启完成后,开始修改垃圾回收为分代ZGC,打开修改框之后删除G1的开关,增加-XX:+UseZGC -XX:+ZGenerational 这两个参数,我顺便修改了-Xms2500m -Xmx2500m 最大最小堆内存,就不需要扩容了,也可以降低卡顿\n关于ZGC调优,经过我之前的测试,ZGC基本是不需要刻意调整的,如果非要调整加大堆内存量,就可以了.\n","date":"2024-03-21T20:25:00+08:00","permalink":"https://chenchenfang.github.io/p/idea-2024.1-%E7%89%88%E6%9C%AC%E6%8F%90%E9%AB%98%E6%B5%81%E7%95%85%E5%BA%A6%E6%96%B9%E6%B3%95/","title":"IDEA 2024.1 版本提高流畅度方法"},{"content":" 平时mysql连接数大概在2000左右,会不定时随机的突然增加到5000,这个事情就很恐怖,所以需要查出来连接数增加的原因\n分析与定位问题 {#%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98 tabindex=\u0026quot;-1\u0026quot;} 分析现有的监控和数据 {#%E5%88%86%E6%9E%90%E7%8E%B0%E6%9C%89%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%B0%E6%8D%AE tabindex=\u0026quot;-1\u0026quot;} 连接数 5000的报警钉钉信息 当连接数5000的时候,数据库里当前连接正在执行的状态 1 SELECT `id`,`user`,`host`,`db`,`command`,`time`,`state`,`info` FROM information_schema.processlist 分析第二个的数据,看到连接基本都在sleep,很少有正在执行的,由于连接数据库是通过内网代理连接的,所以不能直接看出来哪个或者哪些机器导致了这个问题\n增加新的监控 {#%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84%E7%9B%91%E6%8E%A7 tabindex=\u0026quot;-1\u0026quot;} 要定位哪里的问题就需要知道哪个程序或者哪个机器导致的,一步一步深入查,现在连哪个机器导致的问题都不知道,没办法去查,幸运的是这个问题是可以重现的,不必纠结过去没有数据,创造出新的数据再定位问题就行.\n在这里就想到了netstat{.language-plaintext .highlighter-rouge}命令,这个可以在代理机器上执行,查看哪些IP连接了mysql代理服务,并统计个数,于是就把这个命令的触发加到了发送钉钉报警的程序里.\n到这里又想到了一个问题,异常数据有了之后,没有正常的数据做对比还是定位不出来问题,所以增加了每分钟执行一次来保存正常数据用于做对比.\n分析新监控数据 {#%E5%88%86%E6%9E%90%E6%96%B0%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE tabindex=\u0026quot;-1\u0026quot;} 等了1天终于等到了这个报警出现,对比平时的数据来说按连接数倒序,可以看到前边的大多数ip连接数都增加了,问了一下运维这些机器上都有哪些服务,被告知都是线上的tomcat服务.\n到这里总算有了一些进展,但是到了这里又遇到问题了,tomcat里边虽然只有一个项目,但是这个项目中代码量很大,review代码是看不出来也没有办法都review一遍,有什么办法可以定位什么业务创建了连接呢?\n之前读过一遍arthas的文档,对大概的命令以及功能有所了解,于是就想到了 stack{target=\u0026quot;_blank\u0026quot;} 这个命令,这个命令可以打印当前方法的调用堆栈信息,因为创建连接是必须new对象,那么监控这个new对象时候必须调用的方法就可以定位到具体的代码.\n因为这个是随机性的bug,那么靠人手动执行是看不出问题的,于是使用了arthas提供的任务后台执行的方法,后台任务最多执行1天,同时需要指定抓取多少条堆栈信息.\n之前没用过arthas,只是看文档知道执行stack会影响性能,但是具体影响多少性能并不清楚,这里找了一台线上tomcat手动执行stack,并观察了超时情况,超时只增加了0.5%,这个值可以接受,于是就开始后台执行了\n等待新的监控数据 {#%E7%AD%89%E5%BE%85%E6%96%B0%E7%9A%84%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE tabindex=\u0026quot;-1\u0026quot;} 等啊等,终于等到了报警,查看对应时间的连接创建堆栈信息,问题出在缓存读取的方法上.\n如果缓存没有就会读取数据库,同一时间突然有很多都去查询数据库了,原因是缓存里没有对应的数据了,缓存是一个concurrenthashmap,直接做的替换,而同时这个map会根据实际情况增加数据进入,由此可以判断是新加的那部分数据,缓存替换的时候消失了.\n思考解决方案 {#%E6%80%9D%E8%80%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88 tabindex=\u0026quot;-1\u0026quot;} 缓存直接做替换是不行的,会丢失新加入的数据,那首先想到的是更新数据,更新数据会有一个问题是按之前逻辑新增加的那部分数据就会一直存在,内存也会越占用越多,所以需要有删除过期数据的程序,那么问题又来了,这个不好写,就算写了也不好维护.\n这里就想到了Caffeine缓存框架,当真是很强大的本地内存缓存的框架,可以设置多久没有访问就会过期,也支持更新操作,对于我这个需求来说简直完美.\n到了这里这个问题就算解决了,修改代码不过半小时的事情,主要的问题还是如何定位出来哪里代码有问题,\n","date":"2023-12-30T21:32:00+08:00","permalink":"https://chenchenfang.github.io/p/mysql%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%BF%80%E5%A2%9E%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/","title":"mysql连接数激增的问题解决过程"},{"content":" 近期查看有请求下游系统超时,按百分比的话是0.8%的样子,但是每天量很大,超时总数不到1亿次,如果这个可以优化一点,提升巨大的\n1.整体的探索过程 目前只知道最终结果是超时,但是是不是哪里代码写的有问题从而导致的超时,还需要去定位\n1.1初步定为问题 首先记录两个时间,第一个是请求一进来一直到拼接发送请求的位置这段代码的,第二个是拼接请求一直到Response(或者超时了)这段代码的时间\n超时情况:\n不超时情况:\n从图上来看,不管是超时和不超时都第一个时间都不长,所以是拼接请求到接受Response的时候引起的超时\n1.2更细化的定位问题 现在知道是和发送请求有关系了,那么应该对于这部分代码增加详细的记录,来分析问题\nOkHttp监控与调优查资料的时候看到这个文章写的不错\n经过一番查找资料,okhttp有一个EventListener,可以记录发送请求的各个步骤的时间\n于是就有了下边的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 public class PrintingEventListener extends EventListener { @Override public void requestBodyEnd(@NotNull Call call, long byteCount) { printEvent(\u0026#34;requestBodyEnd\u0026#34;); } @Override public void requestBodyStart(@NotNull Call call) { printEvent(\u0026#34;requestBodyStart\u0026#34;); } @Override public void responseBodyEnd(@NotNull Call call, long byteCount) { printEvent(\u0026#34;responseBodyEnd\u0026#34;); } @Override public void responseBodyStart(@NotNull Call call) { printEvent(\u0026#34;responseBodyStart\u0026#34;); } @Override public void responseHeadersEnd(@NotNull Call call, @NotNull Response response) { printEvent(\u0026#34;responseHeadersEnd\u0026#34;); } @Override public void responseHeadersStart(@NotNull Call call) { printEvent(\u0026#34;responseHeadersStart\u0026#34;); } public static final Factory FACTORY = new Factory() { @Override public EventListener create(Call call) { //唯一标识 String randAllString = Format.getRandAllString(10); Random random = new Random(randAllString.hashCode()); double nextDouble = random.nextDouble(); //是tanx 与 10%的概率 if(call.request().url().toString().equals(\u0026#34;xxx\u0026#34;) \u0026amp;\u0026amp; nextDouble * 100 \u0026lt;= 10){ InitServlet.okhttpTimeLog.plus(randAllString,\u0026#34;startSend\u0026#34;,0L,\u0026#34;\u0026#34;); //System.out.printf(\u0026#34;%s %s%n\u0026#34;, randAllString, call.request().url()); return new PrintingEventListener(randAllString, System.nanoTime()); }else{ return EventListener.NONE; } } }; final String callId; final long callStartNanos; public PrintingEventListener(String callId, long callStartNanos) { this.callId = callId; this.callStartNanos = callStartNanos; } private void printEvent(String name) { long elapsedNanos = System.nanoTime() - callStartNanos; InitServlet.okhttpTimeLog.plus(callId,name,elapsedNanos / 1000000L,\u0026#34;\u0026#34;); //System.out.printf(\u0026#34;%s %.0fms %s%n\u0026#34;, callId, elapsedNanos / 1000000d, name); } private void printEvent(String name,IOException ioe){ long elapsedNanos = System.nanoTime() - callStartNanos; InitServlet.okhttpTimeLog.plus(callId,name,elapsedNanos / 1000000L,ioe.getMessage()); //System.out.printf(\u0026#34;%s %.0fms %s %s%n\u0026#34;, callId, elapsedNanos / 1000000d, name,ioe.getMessage()); } @Override public void callStart(Call call) { printEvent(\u0026#34;callStart\u0026#34;); } @Override public void dnsStart(Call call, String domainName) { printEvent(\u0026#34;dnsStart\u0026#34;); } @Override public void dnsEnd(Call call, String domainName, List\u0026lt;InetAddress\u0026gt; inetAddressList) { printEvent(\u0026#34;dnsEnd\u0026#34;); } @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) { printEvent(\u0026#34;connectStart\u0026#34;); } @Override public void secureConnectStart(Call call) { printEvent(\u0026#34;secureConnectStart\u0026#34;); } @Override public void secureConnectEnd(Call call, @Nullable Handshake handshake) { printEvent(\u0026#34;secureConnectEnd\u0026#34;); } @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) { printEvent(\u0026#34;connectEnd\u0026#34;); } @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol, IOException ioe) { printEvent(\u0026#34;connectFailed\u0026#34;); } @Override public void connectionAcquired(Call call, Connection connection) { printEvent(\u0026#34;connectionAcquired\u0026#34;); } @Override public void requestHeadersStart(Call call) { printEvent(\u0026#34;requestHeadersStart\u0026#34;); } @Override public void requestHeadersEnd(Call call, Request request) { printEvent(\u0026#34;requestHeadersEnd\u0026#34;); } @Override public void connectionReleased(Call call, Connection connection) { printEvent(\u0026#34;connectionReleased\u0026#34;); } @Override public void requestFailed(Call call, IOException ioe) { printEvent(\u0026#34;requestFailed\u0026#34;,ioe); } @Override public void responseFailed(Call call, IOException ioe) { printEvent(\u0026#34;responseFailed\u0026#34;,ioe); } @Override public void callFailed(Call call, IOException ioe) { printEvent(\u0026#34;callFailed\u0026#34;,ioe); } @Override public void callEnd(Call call) { printEvent(\u0026#34;callEnd\u0026#34;); } } 这个是记录的结果,这里只放一条数据了,可以明显看出来仅仅是等待Response的时候超时\n2.寻求优化问题的方法 这个问题的根本原因是下游响应时间长导致的,首先我们是不可能去干预下游系统的,那从我们自身来看,有哪些可以优化的地方呢?\n2.1okhttp各种参数的检查 最常见的就是参数优化,调整参数之前需要有相应的日志或者当前数据来支持,没有数据的调参都是瞎搞\n经过一番查找资料,收集了几个okhttp的参数,开始做监控\n1 2 3 4 5 6 7 8 9 10 //新增监控发送给dsp的线程池 val queuedCallsCount = Java_To_Dsp_Handle.OkHttpClientTool.dispatcher.queuedCallsCount() val runningCallsCount = Java_To_Dsp_Handle.OkHttpClientTool.dispatcher.runningCallsCount() val connectionCount = Java_To_Dsp_Handle.OkHttpClientTool.connectionPool.connectionCount() val idleConnectionCount = Java_To_Dsp_Handle.OkHttpClientTool.connectionPool.idleConnectionCount() out.println(\u0026#34;准备好发送的请求:${queuedCallsCount},正在发送的请求:${runningCallsCount}\\n\u0026#34;) out.println(\u0026#34;发送请求的线程池情况:${Java_To_Dsp_Handle.OkHttpClientTool.threadPool}\\n\u0026#34;) out.println(\u0026#34;目前建立的连接数量:${connectionCount},空闲的连接数量:${idleConnectionCount}\\n\u0026#34;) //每个host的请求数 out.println(Java_To_Dsp_Handle.OkHttpClientTool.hostRequestCounterInterceptor.printRequestCountForHost()) 以下是执行完之后的打印\n1 2 3 4 5 6 7 准备好发送的请求:0,正在发送的请求:65 发送请求的线程池情况:java.util.concurrent.ThreadPoolExecutor@3dceaaa5[Running, pool size = 600, active threads = 66, queued tasks = 0, completed tasks = 44826120] 目前建立的连接数量:316,空闲的连接数量:260 host:xxx count:25 分析打印的结果:\n准备好发送的请求如果有值的话,那么就可能发生等待,这里并没有 发送请求的线程池也没有满,也没有等待的任务,所以这个也没问题 再有就是空闲连接也没有达到设置的值,也没问题 最后一个是每个host最大并发数,也远低于设置的值 这一顿操作下来,发现参数并没有问题\n2.2回归代码 一般来说,陈年旧代码有优化空间的概率是比较大的,于是抱着试一试的心态,通读了okhttp发送的相关代码,发现确实有提升空间\nOkHttpClient对象一般是不会创建很多个,所以之前老代码的逻辑是分成5个OkHttpClient对象,也就是5个梯度的等待时间\n比如当前需要等待67毫秒,那么按照梯度会选择超时时间设置为50的OkHttpClient对象,那么这个期间会有17ms的时间损失\n一顿查资料以及测试之后发现,OkHttpClient对象每个请求new一个是不合适的,new这个对象时间比较长,但是可以调用OkHttpClient对象的okclient.newBuilder(){.language-plaintext .highlighter-rouge}方法重新设置超时时间,这种方式基本没有耗时\n升级完成之后,Response的数量有所上涨,超时率数据目前还没出来,等出来了会补上,至此整个分析以及优化过程告一段落\n","date":"2023-10-14T10:06:00+08:00","permalink":"https://chenchenfang.github.io/p/okhttp%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","title":"OkHttp优化过程记录"},{"content":" 周日的时候,突然消费者组就开始堆积了,然后临时解决方案想着重新起一个消费者组看看能不能恢复,然而并不能,无奈之下只能迁回使用redis作为消息中间件的方式,周一再细查一下\n1 遇到的报错以及现象 首先是看的是Dashboard,发现一会消费者组里边有一个消费者,一会没有\n其次就该去看消费者组的业务日志打印了,虽然在消费,但是很慢\n接下来就是看了消费组的RocketMQ日志打印,发现开始报错刷屏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 2023-01-08 12:26:45,649 WARN RocketmqClient - execute the pull request exception org.apache.rocketmq.client.exception.MQBrokerException: CODE: 24 DESC: the consumer\u0026#39;s group info not exist See http://rocketmq.apache.org/docs/faq/ for further details. BROKER: 192.168.1.58:10911 at org.apache.rocketmq.client.impl.MQClientAPIImpl.processPullResponse(MQClientAPIImpl.java:803) at org.apache.rocketmq.client.impl.MQClientAPIImpl.access$200(MQClientAPIImpl.java:175) at org.apache.rocketmq.client.impl.MQClientAPIImpl$2.operationComplete(MQClientAPIImpl.java:754) at org.apache.rocketmq.remoting.netty.ResponseFuture.executeInvokeCallback(ResponseFuture.java:54) at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract$2.run(NettyRemotingAbstract.java:321) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at java.base/java.lang.Thread.run(Thread.java:833) 2023-01-08 12:26:45,649 WARN RocketmqClient - execute the pull request exception org.apache.rocketmq.client.exception.MQBrokerException: CODE: 24 DESC: the consumer\u0026#39;s group info not exist See http://rocketmq.apache.org/docs/faq/ for further details. BROKER: 192.168.1.58:10911 at org.apache.rocketmq.client.impl.MQClientAPIImpl.processPullResponse(MQClientAPIImpl.java:803) at org.apache.rocketmq.client.impl.MQClientAPIImpl.access$200(MQClientAPIImpl.java:175) at org.apache.rocketmq.client.impl.MQClientAPIImpl$2.operationComplete(MQClientAPIImpl.java:754) at org.apache.rocketmq.remoting.netty.ResponseFuture.executeInvokeCallback(ResponseFuture.java:54) at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract$2.run(NettyRemotingAbstract.java:321) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at java.base/java.lang.Thread.run(Thread.java:833) 这个报错卡卡刷屏,于是乎只能去找RocketMQ的消费者client的源码了\n2 源码的追踪 {#2-%E6%BA%90%E7%A0%81%E7%9A%84%E8%BF%BD%E8%B8%AA tabindex=\u0026quot;-1\u0026quot;} 2.1 消费者client端源码 {#2.1-%E6%B6%88%E8%B4%B9%E8%80%85client%E7%AB%AF%E6%BA%90%E7%A0%81 tabindex=\u0026quot;-1\u0026quot;} org.apache.rocketmq.client.impl.MQClientAPIImpl.processPullResponse(MQClientAPIImpl.java:803){.language-plaintext .highlighter-rouge}也就是这一行\n这看着应该是从broker端拉回来的数据有问题,不是正常能消费的数据,那就再往上层看看RemotingCommand response{.language-plaintext .highlighter-rouge}这个对象是怎么来的吧\n再往上一步点的话,会看到有两个地方一个是同步一个是异步,那看的话自然是看同步,毕竟同步代码更简单明了一些,最终的功能肯定是一样的,因为之前学了学netty以及知道RocketMQ是使用Netty通信的,所以看这个方法名字this.remotingClient.invokeSync{.language-plaintext .highlighter-rouge}大概能猜出来它是和broker端进行通信然后获取到要消费的消息,那么接着点进去\n可以看到response{.language-plaintext .highlighter-rouge}对象是从这个方法invokeSyncImpl{.language-plaintext .highlighter-rouge}返回出来的,那就再进去看看\n从这里看的话,并没有对这个对象做特殊的处理,这个时候一定有人有疑问,为什么他就是能正常返回呢,里边还有这么多的if,因为根据CODE: 24 DESC: the consumer's group info not exist{.language-plaintext .highlighter-rouge}\n这个报错就能看出来,response对象一定是有的,并且顺利封装了,要不然不可能有这个报错打印,\n消费者client的源码算是看完了,并没有发现有什么问题,而这个报错是broker端返回给消费者client的,那就去搜搜broker的源码里哪里有这个报错吧\n2.2 broker端源码追踪 首先搜了一下这个报错的内容,org.apache.rocketmq.broker.processor.PullMessageProcessor#processRequest(io.netty.channel.Channel, org.apache.rocketmq.remoting.protocol.RemotingCommand, boolean){.language-plaintext .highlighter-rouge}在这个方法的 178行\n那这里就是this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());{.language-plaintext .highlighter-rouge}返回的结果为null,点进去看看\n发现是这个consumerTable{.language-plaintext .highlighter-rouge}取出来为null\n1 2 private final ConcurrentMap\u0026lt;String/* Group */, ConsumerGroupInfo\u0026gt; consumerTable = new ConcurrentHashMap\u0026lt;String, ConsumerGroupInfo\u0026gt;(1024); 这个对象是一个ConcurrentMap,那如果取出来为null的话,肯定是没有这个key,也就是没有这个消费者组的信息,我明明启动了消费者组怎么可能没有呢,那肯定是在哪个地方给remove掉了,接下来查一下调用remove的方法都在哪里\n1 2 org.apache.rocketmq.broker.client.ConsumerManager#doChannelCloseEvent org.apache.rocketmq.broker.client.ConsumerManager#unregisterConsumer 就是这两个方法的逻辑里有remove方法\n查到这里我感觉需要看一下broker端的日志了\n这么多日志,从何看起呢,先挑着日志多的看吧,毕竟卡卡刷屏,肯定日志量大,文件也不小\n这里的截图应该是已经归档过了的,现在broker.log才16M,记得出问题的时候100多M\n先看broker.log{.language-plaintext .highlighter-rouge}吧\n我从茫茫的打印日志中找到了这个\n看着大概就是说新创建了一个消费者组信息,然后直接就被删掉了\n只有NETTY EVENT: remove not active channel{.language-plaintext .highlighter-rouge}这个是WARN,先查查这个在哪里报的吧\n正好在org.apache.rocketmq.broker.client.ConsumerManager#doChannelCloseEvent{.language-plaintext .highlighter-rouge}\n直接把org.apache.rocketmq.broker.client.ConsumerManager#unregisterConsumer{.language-plaintext .highlighter-rouge}这个排除了\n那么这个方法的上一层就是\n这些方法都是在一个run()方法里边跑的\n看的出来this.eventQueue{.language-plaintext .highlighter-rouge}这个是存放NettyEvent的地方,而这三个方法都是从这里调用的\n那就看什么地方会把NettyEvent放到eventQueue中\n搜一下只有这个类中的putNettyEvent{.language-plaintext .highlighter-rouge}方法才会add\n那再看看这个方法是从哪里调用的吧\n一共有这么多地方调用,想来咱们看的是broker的代码,那肯定是server吧,那就锁定在这四个了\n那也可以看到第一个type类型是CONNECT{.language-plaintext .highlighter-rouge}直接排除,剩下的三个,\n分别都点进去看看,会发现这三个方法都伴随着日志打印\n那咱们就去看看日志打印,然后定位出来具体是哪种事件导致了删除我的消费者组信息\n这里就有个问题,server端那么多日志文件应该看哪个哇?\n我想到了看下这个代码是在哪个包下\n可以看到是remoting,那就看对应名字的log,此时打开消费者,观察日志\n可以看到Active之后,直接Inactive,那肯定是这个事件导致的\n接下来搜这个日志打印,然后就会发现是触发了CLOSE事件\n看到这里就有点懵了,首先是CLOSE事件,这就说明是正常关闭,是因为客户端不活跃导致的,那怎么想都是客户端有问题哇\n3 继续查看客户端日志 兜兜转转一圈,又回到了客户端日志,因为之前刷屏的都是CODE: 24 DESC: the consumer's group info not exist{.language-plaintext .highlighter-rouge},但是这个是WARN类型的日志,我突发奇想,搜搜ERROR看看,果然找到了真正的问题\n这个东西熟啊,这个是Netty的一个解码类,如果消息太长的话会报错,那这个想来应该是消息太长,但是我的消息肯定不会超过1M哇,通过堆栈可以看到是org.apache.rocketmq.remoting.netty.NettyDecoder.decode这里报错的,\n报错的是42行,那这个就是说当前消息太大了,解码出了问题,我猜想是把多个消息包装成一个大的消息,然后消费者client在进行解包处理,因为我的消息可能存才接近1M的,然后我一次获取100个消息,这样合并的话肯定会超过这个16777216 于是我在消费者启动上增加-Dcom.rocketmq.remoting.frameMaxLength=167772160,增加10倍看看,重新启动发现有效果,比之前好点了,起码不是刷屏报错了,但是还是不正常,偶尔还是有刷屏,Dashboard上也是一会有消费者一会没有,这样子还是不正常,那这样子的话只能把一次获取消息的个数减少了,于是我减少到了10,也就是这个参数consumer.pullBatchSize = 10 到这里这个报错总算是没有了,以我目前的技术水平,算是解决了问题,但是还是没有找到问题出在哪里\nRemotingUtil.closeChannel(ctx.channel());其中报错之后会调用这个关闭channel,估计是因为这个,具体之后再学习学习吧.\n4 总结 通过这次的源码跟踪查问题,体会到了RocketMQ的消息真的不能太大,不然会出现各种各样奇怪的问题,但是我们业务那边的消息如果按一个一个发送那真的是太多了,只能是业务那边合并成一个消息,然后再批量发到MQ,这就导致了单个消息可能接近1M,同时消费者的话一次拉取消息也不能太多\u0026hellip;毕竟太多也处理不过来,索性减低一下速度,也是没有问题的,问题解决了,接下来就是把生产的东西往MQ中迁移了,希望不会再有问题\u0026hellip;\n","date":"2023-01-09T22:49:00+08:00","permalink":"https://chenchenfang.github.io/p/rocketmq%E6%B6%88%E6%81%AF%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E4%B8%8D%E4%BA%86%E5%AF%BC%E8%87%B4%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/","title":"RocketMQ消息过大导致消费者消费不了,导致消息堆积"},{"content":"java.lang.NoSuchFieldError 报错排查问题 排查过程 报这个错的根本原因是运行时找不到对应的变量,那么为什么会找不到呢,因为运行的时候使用了错误的类 为什么会使用错误的类呢,是因为使用了错误版本的jar包 怎么会使用到错误的jar包呢 明明编译的时候好好的\n我这个跟业务有点关系,对接别人的sdk,他们文档中写的是把5个jar包上传到自己的maven私服,然后项目中就可以使用了,最开始以为是他们自己的私有的jar,后来发现不是这样,有开源项目的jar,bcprov-jdk15on这个加解密的包\n上传到私库的时候,使用了跟开源库不同的groupId,导致打出来的包里有两个不同版本的相同jar包,导致运行时使用了错误的jar包的类 所以才会报这个错误 于是我把自己项目中的bcprov-jdk15on版本升级到了sdk给的版本,\n就可以正常运行了\n","date":"2022-06-30T23:35:00+08:00","permalink":"https://chenchenfang.github.io/p/java.lang.nosuchfielderror-%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","title":"java.lang.NoSuchFieldError 报错解决方法"},{"content":"1.三个时间的含义 {#1.%E4%B8%89%E4%B8%AA%E6%97%B6%E9%97%B4%E7%9A%84%E5%90%AB%E4%B9%89 tabindex=\u0026quot;-1\u0026quot;} access time （atime）\n当\u0026quot;该文件的内容被取用\u0026quot;时，就会更新这个读取时间 （access）。 modification time （mtime）\n当该文件的\u0026quot;内容数据\u0026quot;变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限。 status time （ctime）\n当该文件的\u0026quot;状态 （status）\u0026ldquo;改变时，就会更新这个时间。\n举例来说，像是权限与属性被更改了，文件内容修改，都会修改这个时间。 2.查看这三个时间的命令 {#2.%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%89%E4%B8%AA%E6%97%B6%E9%97%B4%E7%9A%84%E5%91%BD%E4%BB%A4 tabindex=\u0026quot;-1\u0026rdquo;} 1.stat命令 {#1.stat%E5%91%BD%E4%BB%A4 tabindex=\u0026quot;-1\u0026quot;} 1 2 3 4 5 6 7 8 [root@agent-54 ~]# stat a.txt File: \u0026#34;a.txt\u0026#34; Size: 0 Blocks: 0 IO Block: 4096 普通空文件 Device: fd01h/64769d Inode: 394816 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2021-01-01 01:01:00.000000000 +0800 Modify: 2021-01-01 01:01:00.000000000 +0800 Change: 2022-04-18 21:50:49.546704098 +0800 里边三个时间分别对应介绍的三个时间\n2.ls查看 {#2.ls%E6%9F%A5%E7%9C%8B tabindex=\u0026quot;-1\u0026quot;} 1 2 3 4 5 6 [root@agent-54 ~]# ls --full-time --time=atime a.txt -rw-r--r-- 1 root root 0 2021-01-01 01:01:00.000000000 +0800 a.txt [root@agent-54 ~]# ls --full-time a.txt -rw-r--r-- 1 root root 0 2021-01-01 01:01:00.000000000 +0800 a.txt [root@agent-54 ~]# ls --full-time --time=ctime a.txt -rw-r--r-- 1 root root 0 2022-04-18 21:50:49.546704098 +0800 a.txt 3.touch修改access time和modification time {#3.touch%E4%BF%AE%E6%94%B9access-time%E5%92%8Cmodification-time tabindex=\u0026quot;-1\u0026quot;} ctime是修改不了的，它是随着另外两个时间的变化而变化\n首先我们来看一个 touch的help信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [root@agent-54 ~]# touch --help 用法：touch [选项]... 文件... 将每个文件的访问时间和修改时间改为当前时间。 不存在的文件将会被创建为空文件，除非使用-c 或-h 选项。 如果文件名为\u0026#34;-\u0026#34;则特殊处理，更改与标准输出相关的文件的访问时间。 长选项必须使用的参数对于短选项时也是必需使用的。 -a 只更改访问时间 -c, --no-create 不创建任何文件 -d, --date=字符串 使用指定字符串表示时间而非当前时间 -f (忽略) -h, --no-dereference 会影响符号链接本身，而非符号链接所指示的目的地 (当系统支持更改符号链接的所有者时，此选项才有用) -m 只更改修改时间 -r, --reference=文件 使用指定文件的时间属性而非当前时间 -t STAMP 使用[[CC]YY]MMDDhhmm[.ss] 格式的时间而非当前时间 --time=WORD 使用WORD 指定的时间：access、atime、use 都等于-a 选项的效果，而modify、mtime 等于-m 选项的效果 --help 显示此帮助信息并退出 --version 显示版本信息并退出 请注意，-d 和-t 选项可接受不同的时间/日期格式。 请向bug-coreutils@gnu.org 报告touch 的错误 GNU coreutils 项目主页：\u0026lt;http://www.gnu.org/software/coreutils/\u0026gt; GNU 软件一般性帮助：\u0026lt;http://www.gnu.org/gethelp/\u0026gt; 请向\u0026lt;http://translationproject.org/team/zh_CN.html\u0026gt; 报告touch 的翻译错误 要获取完整文档，请运行：info coreutils \u0026#39;touch invocation\u0026#39; 其中 -a -m 用来修改不同的时间，-t 指定要修改的具体时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [root@agent-54 ~]# touch -a -t 202002030355 a.txt [root@agent-54 ~]# stat a.txt File: \u0026#34;a.txt\u0026#34; Size: 0 Blocks: 0 IO Block: 4096 普通空文件 Device: fd01h/64769d Inode: 394816 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2020-02-03 03:55:00.000000000 +0800 Modify: 2021-01-01 01:01:00.000000000 +0800 Change: 2022-04-18 22:23:12.490390037 +0800 [root@agent-54 ~]# touch -m -t 202006060606 a.txt [root@agent-54 ~]# stat a.txt File: \u0026#34;a.txt\u0026#34; Size: 0 Blocks: 0 IO Block: 4096 普通空文件 Device: fd01h/64769d Inode: 394816 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2020-02-03 03:55:00.000000000 +0800 Modify: 2020-06-06 06:06:00.000000000 +0800 Change: 2022-04-18 22:26:28.588715086 +0800 ","date":"2022-04-18T22:27:00+08:00","permalink":"https://chenchenfang.github.io/p/linux%E4%B8%8B%E7%9A%84atime-mtime-ctime%E6%9F%A5%E7%9C%8B%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9/","title":"Linux下的atime mtime ctime查看以及修改"},{"content":"ClassNotFoundException 和 NoClassDefFoundError 1. ClassNotFoundException Class.forName(), ClassLoader.loadClass() or ClassLoader.findSystemClass() 一般是这几个方法,运行的时候会报错\n因为这个去加载不存在的类\n编译期间就没有这个类\n1 2 3 4 public void givenNoDrivers_whenLoadDriverClass_thenClassNotFoundException() throws ClassNotFoundException { Class.forName(\u0026#34;oracle.jdbc.driver.OracleDriver\u0026#34;); } 2.NoClassDefFoundError 一般是因为类初始化 没有成功 因为类初始化只会初始化一次,第二次调用这个class 用于生成对象或者是静态变量,都会报错\n编译期间有这个类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ClassWithInitErrors { static int data = 1 / 0; } public class NoClassDefFoundErrorExample { public ClassWithInitErrors getClassWithInitErrors() { ClassWithInitErrors test; try { test = new ClassWithInitErrors(); } catch (Throwable t) { System.out.println(t); } test = new ClassWithInitErrors(); return test; } } @Test public void givenInitErrorInClass_whenloadClass_thenNoClassDefFoundError() { NoClassDefFoundErrorExample sample = new NoClassDefFoundErrorExample(); sample.getClassWithInitErrors(); } ","date":"2021-07-11T14:33:00+08:00","permalink":"https://chenchenfang.github.io/p/classnotfoundexception-%E5%92%8C-noclassdeffounderror-%E5%8C%BA%E5%88%AB/","title":"ClassNotFoundException 和 NoClassDefFoundError 区别"},{"content":"spring MVC 校验Get请求的参数 很多时候都是使用 POST请求然后传入请求体，用类来接受请求数据，但有时候就只有一个参数，不想去创建类了，然后也想使用校验注解去校验这个参数，那么接下来会介绍这种方法。\n1 2 3 4 5 6 7 //在类上声明注解 @Validated 下方的参数可以直接使用 校验注解 进行校验 @Validated public class UserAdminController { public JsonResult generatePortalJwtTokenByAdminGroupId( @NotNull Integer adminGroupId) throws CybercloudException { } } ","date":"2021-05-16T07:22:00+08:00","permalink":"https://chenchenfang.github.io/p/spring-mvc-%E6%A0%A1%E9%AA%8Cget%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%82%E6%95%B0/","title":"spring MVC 校验Get请求的参数"},{"content":"Java内存区域 首先看一下 Java 内存区域图:\n程序计数器 程序计数器是一块较小的内存空间,它可以看做是当前线程所执行的字节码的行号指示器.\nJava虚拟机的概念模型里,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码执行.\n在多线程中,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各个线程之间计数器互不影响,独立存储,所以为\u0026quot;线程私有\u0026quot;的内存.\nJava虚拟机栈 Java虚拟机栈也是\u0026quot;线程私有\u0026quot;,声明周期与线程相同.\nJava虚拟机栈描述的是Java方法执行的内存模型\n每个方法被执行的时候,Java虚拟机都会创建一个栈帧用于存储局部变量表操作数栈 动态连接 方法出口等信息.\n每一个方法被调用直至执行完毕的过程,就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程.\n一般会把内存分为 堆内存和栈内存, 这里说的栈内存就是指 Java虚拟机栈中的局部变量表\n局部变量表中 存放了这个方法运行时各种Java虚拟机基本数据类型(boolean byte char short int float long double),对象引用和returnAddress类型.\n这些数据类型的存储空间以局部变量槽(Slot)表示,其中long和double占用2个槽,其他占用1个槽,局部变量表所需的局部变量槽的数量在编译期间确定下来,一个槽的真正使用内存空间的多少,取决于具体虚拟机如何实现,可能是 32位也可能是64位\n","date":"2021-03-22T08:02:07+08:00","permalink":"https://chenchenfang.github.io/p/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","title":"Java内存区域"},{"content":"java 四舍五入问题 前两天,在工作中遇到了一个问题,公司运营说:\u0026quot;我上传数据,没有给我四舍五入,是不是你程序有问题?\u0026quot;.那我当时肯定是想程序都用这么长时间了...不能有问题吧. 但是还是说:\u0026quot;把具体的问题数据,以及什么可以重现,都说一下\u0026quot;,接下来是解决问题的心路历程.\n复现bug 问题数据已经有了,接下来就是如何重现这个问题.主要的问题代码就是下边\n1 2 long round = Math.round(Double.valueOf(\u0026#34;150.795\u0026#34;) * 100); System.out.println(round); 其中Double.valueOf(\u0026quot;150.795\u0026quot;){.language-plaintext .highlighter-rouge}没有问题,然后 做*100{.language-plaintext .highlighter-rouge}操作,这里结果就有问题了,结果是15079.499999999998{.language-plaintext .highlighter-rouge}.\n之前都说 double不准什么的,也没体会到,现在真的是体会到了......\n解决问题 最终是需要实现 四舍五入保留两位小数,那就去看BigDecimal{.language-plaintext .highlighter-rouge}这个吧,都说这个计算是准确的.\n1 2 3 4 private Double round(double f) { BigDecimal b = BigDecimal.valueOf(f); return b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); } 最终使用的是这个解决方案.\n但是这里也有个坑,就是传入的double最好是没有计算过的,不然也会出现上边 *100{.language-plaintext .highlighter-rouge}之后结果有问题\n一般来说界面填写数值,然后传入到后端获取都是 String{.language-plaintext .highlighter-rouge}类型的,直接调用方法就行,如果需要计算的话,用BigDecimal{.language-plaintext .highlighter-rouge}计算\n","date":"2021-01-02T15:42:00+08:00","permalink":"https://chenchenfang.github.io/p/java-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E9%97%AE%E9%A2%98/","title":"java 四舍五入问题"},{"content":"maven-shade-plugin 使用方法 之所以发这个,是因为前段时间,spark项目打包,到服务器上之后,出现了不同版本jar包冲突的问题,然后使用了这个插件解决了问题.\n一: relocation的使用 因为服务器上的jar不能删除,也不能替换,但是我用的jar包也只能用和服务器上不同的版本.\n使用这个功能可以完美的解决这个问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;relocations\u0026gt; \u0026lt;relocation\u0026gt; \u0026lt;!--原本的包名--\u0026gt; \u0026lt;pattern\u0026gt;okhttp3\u0026lt;/pattern\u0026gt; \u0026lt;!--要替换成的包名--\u0026gt; \u0026lt;shadedPattern\u0026gt;fang7.okhttp3\u0026lt;/shadedPattern\u0026gt; \u0026lt;/relocation\u0026gt; \u0026lt;/relocations\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; 这样就可以解决包名冲突的问题\n二: artifactSet excludes 去掉依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;artifactSet\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;com.squareup.okhttp3:okhttp\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/artifactSet\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; 将该工程依赖的部分 Jar 包 include/exclude 掉。\n","date":"2021-01-01T21:14:00+08:00","permalink":"https://chenchenfang.github.io/p/maven-shade-plugin-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","title":"maven-shade-plugin 使用方法"},{"content":" 为什么说这个呢,因为今天新入职的开发问了我一个问题 就是今天出现的bug,日期格式化出现了明年的时间\n当时并没有仔细看,由于之前用的还是 Date类(java8之后使用LocalDate类更好用),所以把LocalDate的一个代码复制给他了,试了试直接能用,也就没有管.\n然后第二天早晨看微信公众号的时候看有人发了一个 关于 YYYY-MM-dd的消息,然后点进去看了一下才知道应该使用 yyyy-MM-dd ,记录一下.\n1 2 3 4 5 6 7 8 9 String format = LocalDate.of(2020, 12, 27).format(DateTimeFormatter.ofPattern(\u0026#34;YYYY-MM-dd\u0026#34;)); System.out.println(\u0026#34;YYYY-MM-dd:\u0026#34;+format); format = LocalDate.of(2020, 12, 27).format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;)); System.out.println(\u0026#34;yyyy-MM-dd:\u0026#34;+format); //输出的是 //YYYY-MM-dd:2021-12-27 //yyyy-MM-dd:2020-12-27 首先可以看源码\n周所在的年\n查了一下有这个说法:\n当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，那么这周就算入下一年\n总结: 用yyyy-MM-dd 就完事了\n","date":"2020-12-30T20:57:00+08:00","permalink":"https://chenchenfang.github.io/p/java%E4%B8%AD-yyyy-mm-dd-%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%97%AE%E9%A2%98/","title":"java中 YYYY-MM-dd 格式化问题"},{"content":"Springboot中排除自动配置的 3 种方法 springboot中排除自动配置\n1.@SpringBootApplication 注解中去掉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.bind.Bindable; import org.springframework.boot.context.properties.bind.Binder; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication(exclude = {MyAppAutoConfiguration.class}) public class StartApplication { public static void main(String[] args) { ConfigurableApplicationContext run = SpringApplication.run(StartApplication.class, args); Binder binder = Binder.get(run.getEnvironment()); String s = binder.bind(\u0026#34;myapp.company\u0026#34;, Bindable.of(String.class)).get(); System.out.println(s); } } 2.@EnableAutoConfiguration注解中去掉 1 2 3 4 5 6 7 import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.context.annotation.Configuration; @Configuration @EnableAutoConfiguration(exclude = {MyAppAutoConfiguration.class}) public class ConfigTest { } 3.配置文件中去掉 1 2 3 4 5 6 7 8 9 server: port: 8081 myapp: name: 嘿嘿嘿 company: 我是公司 spring: autoconfigure: exclude: - com.fang7.spring.boot.autoconfigure.MyAppAutoConfiguration ","date":"2020-12-06T20:21:00+08:00","permalink":"https://chenchenfang.github.io/p/springboot%E4%B8%AD%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-3-%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"Springboot中排除自动配置的 3 种方法"},{"content":"java创建线程的几种方式 一: 继承Thread 相当简单...\n重写run方法即可\n1 2 3 4 5 6 7 8 9 10 11 public class TRunnbale extends Thread{ public static void main(String[] args) { TRunnbale tRunnbale = new TRunnbale(); tRunnbale.start(); } @Override public void run() { System.out.println(\u0026#34;我要跑线程了\u0026#34;); } } 二:实现Runnable接口 这个是最简单的方式,直接实现Runnable接口 然后实现run()方法\n最后放入 new Thread()中,然后 start()执行就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class TRunnbale { public static void main(String[] args) { new Thread(new MyTask()).start(); } } class MyTask implements Runnable{ @Override public void run() { System.out.println(\u0026#34;我要跑线程了!\u0026#34;); } } 三: 实现Callable接口 这个接口里需要实现的那个方法,是有一个返回值的,然后可以完成每个线程结束后,返回一个参数,线程外部可以接受这个参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class TRunnbale extends Thread{ public static void main(String[] args) { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask(new MyTask()); new Thread(futureTask, \u0026#34;线程A\u0026#34;).start(); try { String result = futureTask.get(); System.out.println(result); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } class MyTask implements Callable\u0026lt;String\u0026gt;{ @Override public String call() throws Exception { // Do something... return \u0026#34;线程结束!\u0026#34;; } } 这里有一个FutureTask\n咱们看一下这个类的源码,首先这个类实现了RunnableFuture这个接口\nRunnableFuture这个接口 有继承了Runnable和Future\nRunnable都知道是什么,这个接口是为了可以在 new Thread()中传入,\n因为 Thread最终的start()方法就是执行run()方法中的代码\n到现在可能会迷惑 Runnable不是没有返回值么,这个Future的返回值是怎么实现的呢,\n咱们看下FutureTask的源码\nThread会调用run()方法,然后里边调用了new FutureTask(new MyTask());\n里Callable的call()方法然后把这个值设置到当前对象的outcome参数上\n然后主线程调用FutureTask的对象的get()方法,获得outcome这个值\n当然get()方法会堵塞当前线程,一直到获取返回值后,再往后执行,\n(之后会整理一下FutureTask的相关知识,这里就不具体说了)\n四:使用java多线程来创建线程 todo...\n","date":"2020-11-19T22:33:07+08:00","permalink":"https://chenchenfang.github.io/p/java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","title":"java创建线程的几种方式"},{"content":" sql行变列 列变行 总是忘记,还是记下来比较好\n行变列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 CREATE TABLE tb_score( id INT(11) NOT NULL auto_increment, userid VARCHAR(20) NOT NULL COMMENT \u0026#39;用户id\u0026#39;, subject VARCHAR(20) COMMENT \u0026#39;科目\u0026#39;, score DOUBLE COMMENT \u0026#39;成绩\u0026#39;, PRIMARY KEY(id) )ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;001\u0026#39;,\u0026#39;语文\u0026#39;,90); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;001\u0026#39;,\u0026#39;数学\u0026#39;,92); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;001\u0026#39;,\u0026#39;英语\u0026#39;,80); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;002\u0026#39;,\u0026#39;语文\u0026#39;,88); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;002\u0026#39;,\u0026#39;数学\u0026#39;,90); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;002\u0026#39;,\u0026#39;英语\u0026#39;,75.5); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;003\u0026#39;,\u0026#39;语文\u0026#39;,70); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;003\u0026#39;,\u0026#39;数学\u0026#39;,85); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;003\u0026#39;,\u0026#39;英语\u0026#39;,90); INSERT INTO tb_score(userid,subject,score) VALUES (\u0026#39;003\u0026#39;,\u0026#39;政治\u0026#39;,82); 1 2 3 4 5 6 select userid, max(case `subject` when \u0026#39;语文\u0026#39; then score else 0 end ) as \u0026#39;语文\u0026#39;, max(case `subject` when \u0026#39;数学\u0026#39; then score else 0 end ) as \u0026#39;数学\u0026#39;, max(case `subject` when \u0026#39;英语\u0026#39; then score else 0 end ) as \u0026#39;英语\u0026#39; from tb_score group by userid 列变行 1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TABLE tb_score1( id INT(11) NOT NULL auto_increment, userid VARCHAR(20) NOT NULL COMMENT \u0026#39;用户id\u0026#39;, cn_score DOUBLE COMMENT \u0026#39;语文成绩\u0026#39;, math_score DOUBLE COMMENT \u0026#39;数学成绩\u0026#39;, en_score DOUBLE COMMENT \u0026#39;英语成绩\u0026#39;, po_score DOUBLE COMMENT \u0026#39;政治成绩\u0026#39;, PRIMARY KEY(id) )ENGINE = INNODB DEFAULT CHARSET = utf8; INSERT INTO tb_score1(userid,cn_score,math_score,en_score,po_score) VALUES (\u0026#39;001\u0026#39;,90,92,80,0); INSERT INTO tb_score1(userid,cn_score,math_score,en_score,po_score) VALUES (\u0026#39;002\u0026#39;,88,90,75.5,0); INSERT INTO tb_score1(userid,cn_score,math_score,en_score,po_score) VALUES (\u0026#39;003\u0026#39;,70,85,90,82); 1 2 3 4 5 6 7 8 9 10 11 select userid,\u0026#39;语文\u0026#39; as \u0026#39;subject\u0026#39;,cn_score as \u0026#39;score\u0026#39; from tb_score1 group by userid union all select userid,\u0026#39;数学\u0026#39; as \u0026#39;subject\u0026#39;,math_score as \u0026#39;score\u0026#39; from tb_score1 group by userid union all select userid,\u0026#39;英语\u0026#39; as \u0026#39;subject\u0026#39;,en_score as \u0026#39;score\u0026#39; from tb_score1 group by userid ","date":"2020-11-06T21:04:00+08:00","permalink":"https://chenchenfang.github.io/p/sql-%E8%A1%8C%E5%8F%98%E5%88%97-%E5%88%97%E5%8F%98%E8%A1%8C/","title":"sql 行变列 列变行"},{"content":" 最开始是让优化一个报表的SQL,因为时间太长了,然后看到join了一个表,这个表 是个group by ,然后select中使用了GROUP_CONCAT()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT place_id, GROUP_CONCAT( appname SEPARATOR \u0026#39; \u0026#39; ) appname, GROUP_CONCAT( appid SEPARATOR \u0026#39; \u0026#39; ) appid, type, CASE WHEN GROUP_CONCAT( appid SEPARATOR \u0026#39;\u0026#39; ) = \u0026#39;\u0026#39; THEN \u0026#39;PC\u0026#39; ELSE GROUP_CONCAT( platform SEPARATOR \u0026#39; \u0026#39; ) END AS platform FROM places_info GROUP BY place_id 这个SQL就用20秒,然后考虑做一个cache表,这样查起来就很快也很方便.\n做cache表用的是 insert into select ,\n然后报错\n1 1260 - Row 20094 was cut by GROUP_CONCAT(), Time: 0.153000s 查了一下说是,GROUP_CONCAT()最大允许结果长度默认是1024,这个值可以设置 group_concat_max_len\n1 2 SET global group_concat_max_len=15000; SET session group_concat_max_len=15000; 两种方式可以设置\n我选择的是session 只针对当次回话有效.然后再执行 insert into select{.language-plaintext .highlighter-rouge}就OK了\n","date":"2020-11-04T21:57:00+08:00","permalink":"https://chenchenfang.github.io/p/mysql%E4%B8%AD-group_concat-%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"mysql中 GROUP_CONCAT() 的使用"},{"content":"find命令 \\[-H \\| -L \\| -P\\]\\[-EXdsx\\]\\[-f path\\]\\[expression\\]-name 1 2 find . -name \u0026#34;*.java\u0026#34; find . -iname \u0026#34;*.java\u0026#34; iname 不区分大小写\n-type 1 find . -type d 按类型查找\n类型参数列表：\nf 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p Fifo -size 文件大小单元：\nb \u0026mdash;\u0026mdash; 块（512字节） c \u0026mdash;\u0026mdash; 字节 w \u0026mdash;\u0026mdash; 字（2字节） k \u0026mdash;\u0026mdash; 千字节 M \u0026mdash;\u0026mdash; 兆字节 G \u0026mdash;\u0026mdash; 吉字节 1 2 3 find / -size +10M find / -size -10M find / -size 10M +搜索大于10M的\n-搜索小于10M的\nmaxdepth mindepth 向下最大深度限制为3\n1 find / -maxdepth 3 -type f 搜索出深度距离当前目录至少2个子目录的所有文件\n1 find / -mindepth 2 -type f -perm 根据文件权限/所有权进行匹配 1 2 3 4 5 6 //权限是 644的文件 find . -perm 644 -type f //用户是tom find . -user tom //组是hadoop find . -group hadoop 其中 perm还有 -perm +644{.language-plaintext .highlighter-rouge} -perm -644{.language-plaintext .highlighter-rouge}\n拿二进制比较好说一点\n644 ===\u0026gt; 110100100\n+{.language-plaintext .highlighter-rouge}是说 位数为1的匹配上一个就行\n-{.language-plaintext .highlighter-rouge}是说 位数为1的必须都匹配上才行\n+{.language-plaintext .highlighter-rouge} -{.language-plaintext .highlighter-rouge}的0位都不用管\n-exec 1 find . -type f -name \u0026#34;*.txt\u0026#34; -exec cat {} \\; {}代表的是 前边查出来的那些文件的路径及文件名\n1 2 3 4 5 ❯ find . -size +1M -exec ls -l {} \\; -rw-r--r--@ 1 ziang staff 184354523 10 23 17:45 ./spark-2.0.0-bin-hadoop2.6.tgz ❯ find ~/Downloads -size +1M -exec ls -l {} \\; -rw-r--r--@ 1 ziang staff 184354523 10 23 17:45 /Users/ziang/Downloads/spark-2.0.0-bin-hadoop2.6.tgz 可见{}的内容是相对于 之前输入的路径的\n然后可以对他们进行操作\nexec 必须以 ;{.language-plaintext .highlighter-rouge}结尾 然后 ;{.language-plaintext .highlighter-rouge}属于字符 需要转义所以结尾成了\\;{.language-plaintext .highlighter-rouge}\n","date":"2020-10-25T17:53:07+08:00","permalink":"https://chenchenfang.github.io/p/find%E5%91%BD%E4%BB%A4%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/","title":"find命令常用参数"},{"content":"原码 反码 补码 一:为什么会有原码反码补码? 为了让计算机更简单的计算数值.所以计算机用补码\n具体怎么实现,后边会说,接下来先看一下 什么是原码 反码和补码\n二:正数的原码 反码 补码 网上大多都是按 原码 反码 补码 分别去介绍,博主(本人)感觉这样的方法并不方便理解.所以改用 正数和负数来说\n如果按int来的话,0太多了,看着不方便,就是8位来表示吧.\n正数就是 把十进制的数 变成二进制而已\n正数的原码 反码 补码是一样的{.language-plaintext .highlighter-rouge}\n\\[+1\\]\\[00000001\\]\\[00000001\\]\\[00000001\\]（补码）\n三:负数的原码 反码 补码 原码:最高位为1{.language-plaintext .highlighter-rouge} 代表这个数是负数\n反码: 符号位不变{.language-plaintext .highlighter-rouge},其他位取反\n补码: 反码 + 1{.language-plaintext .highlighter-rouge}\n\\[-1\\]\\[10000001\\]\\[11111110\\]\\[11111111\\]（补码）\n四:原码 反码 补码出现的意义 他们的出现都是为了让计算机计算的更加简单,从而性能更好.\n知识: 1 - 1 = 1 + (-1) 所以机器可以只有加法.\n首先如果只是原码计算,人可以很方便的计算出数值,因为人可以分清符号位.\n可是计算机想识别符号位,是很麻烦的.有什么方法能让计算机更简单的计算呢,于是就有了反码.\n接下来看,反码的计算\n1 2 3 4 5 6 7 8 9 10 11 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 反码已经可以让计算机计算更简单.但是为什么还有补码呢.\n\\[1111 1111\\]\\[-0\\]\\[0000 0000\\]\\[+0\\]正负0是没有意义的,所以补码是为了解决 0 有两个编码的问题.\n(其实到这里 反码是不能直接看出来它代表哪个数,就需要理解了,补码再反码的基础上+1,就更加难理解,我也尝试用更简单的方法来表达出来,有问题可以提出写到评论里)\n补码中规定:0的编码为[0000 0000]补 = [+0]{.language-plaintext .highlighter-rouge}\n在这里先不要去想二进制代表的十进制数,只想象它是编码{.language-plaintext .highlighter-rouge}\n首先 8位的二进制,就只有0000 0000 到 1111 1111 这么多个编码 (从0000 0000 开始+1)\n然后正数原码反码补码 都是一样的,那么咱们去掉0000 0000 到 0111 1111\n剩下的就是1000 0000 到 1111 1111 这些数值这些都是负数(因为符号位是1)\n这些编码挨个+1 是这样的\n1 2 3 4 5 6 7 1000 0000 1000 0001 1000 0010 .... 1111 1101 1111 1110 1111 1111 首先这些编码 如果是原码那么对应成十进制就是\n1 2 3 4 5 6 7 -0 -1 -2 .... -125 -126 -127 反码不是可以让计算机计算方便么,这些编码是反码 对应的十进制是\n1 2 3 4 5 6 7 -127 -126 -125 ... -2 -1 -0 不是有-0么 怎么解决这个-0呢, 每个数-1,不就没有-0了么,最后变成了\n1 2 3 4 5 6 7 -128 -127 -126 ... -3 -2 -1 完美解决-0的编码问题,而且多了一个-128{.language-plaintext .highlighter-rouge},这就是为什么java中int取值范围是 $-2^{31}$\\ ~\\ $2^{31}-1$\n好了现在讨论反码怎么才能变成这些数呢,\n-1的反码是 1111 1110 ,然后现在-1的编码{.language-plaintext .highlighter-rouge}变成了1111 1111(这个就是-1的补码了)\n综上所述: 补码=反码+1{.language-plaintext .highlighter-rouge}\n补码就是这么来的.所以计算机使用补码可以更快的是实现计算.(反码也可以,但是还是有-0问题,所以还是使用补码)\n","date":"2020-09-26T19:18:07+08:00","permalink":"https://chenchenfang.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/","title":"计算机的原码 反码 补码"},{"content":"移位运算符 最近在看HashMap的源码,其中有 \u0026lt;\u0026lt;{.language-plaintext .highlighter-rouge}或者 \u0026gt;\u0026gt;\u0026gt;{.language-plaintext .highlighter-rouge} 就很懵逼 然后就去学习了一下 总结一下,之后如果忘了还可以再过来看\n原码,反码,补码 计算机中存储数字是按二进制存储的,然后存的是补码.目前只知道存的是补码,我也不知道为什么存补码\n之后再详细看看再补充吧\n1、左移运算符：\u0026lt;\u0026lt; 丢弃最高位，0补最低位\n拿int{.language-plaintext .highlighter-rouge}来举例,int是32位的.\n就是二进制集体往左移动多少位\n(如果移动的位数x大于等于32,那么就x%32取余)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 123 ===\u0026gt; 0000 0000 0000 0000 0000 0000 0111 1011 123 \u0026lt;\u0026lt; 2 ===\u0026gt; 0000 0000 0000 0000 0000 0001 1110 1100 移动位数大于等于32 那么就会取余,即: 32%32 = 0 123 ===\u0026gt; 0000 0000 0000 0000 0000 0000 0111 1011 123 \u0026lt;\u0026lt; 32 ===\u0026gt; 0000 0000 0000 0000 0000 0000 0111 1011 如果正好移位后的符号位为0 那么就会变成正数 -123 ===\u0026gt; 1111 1111 1111 1111 1111 1111 1000 0101 -123 \u0026lt;\u0026lt; 25 ===\u0026gt; 0000 1010 0000 0000 0000 0000 0000 0000 2、右移运算符(带符号右移)：\u0026gt;\u0026gt; 符号位不变，左边补上符号位\n就是二进制集体往右移动多少位\n(如果移动的位数x大于等于32,那么就x%32取余)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 123 ====\u0026gt; 0000 0000 0000 0000 0000 0000 0111 1011 123 \u0026gt;\u0026gt; 2 ===\u0026gt; 0000 0000 0000 0000 0000 0000 0001 1110 123 \u0026gt;\u0026gt; 34 (移动位数大于等于32 那么就会取余, 即: 34%32 = 2) ===\u0026gt; 0000 0000 0000 0000 0000 0000 0001 1110 -123 ====\u0026gt; 1111 1111 1111 1111 1111 1111 1000 0101 -123 \u0026gt;\u0026gt; 8 ===\u0026gt; -1 1111 1111 1111 1111 1111 1111 1111 1111 3、右移运算符(无符号右移)：\u0026gt;\u0026gt;\u0026gt; 忽略了符号位扩展，0补最高位\n1 2 3 4 -123 ====\u0026gt; 1111 1111 1111 1111 1111 1111 1000 0101 -123 \u0026gt;\u0026gt;\u0026gt; 8 ===\u0026gt; 16777215 0000 0000 1111 1111 1111 1111 1111 1111 ","date":"2020-09-22T22:35:00+08:00","permalink":"https://chenchenfang.github.io/p/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-java/","title":"移位运算符-java"},{"content":"单例模式 一 : 枚举单例 java中的枚举,只会初始化一次,所以枚举可以直接实现单例,直接上代码吧很简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Singleton { private Singleton() {} private enum EnumSingleton { INSTANCE; private Singleton singleton; EnumSingleton() { singleton = new Singleton(); } public Singleton getSingleton() { return singleton; } } public static Singleton getSingleton() { return EnumSingleton.INSTANCE.getSingleton(); } public static void main(String[] args) { Singleton singleton = Singleton.getSingleton(); System.out.println(singleton); } } 二 : 内部类单例 在类的内部,再声明一个静态类,在静态类里边初始化外部的那个类\n1 2 3 4 5 6 7 8 9 10 11 12 public class SingletonInnerClass { private SingletonInnerClass() { } private static class Singleton { private static SingletonInnerClass singletonInnerClass = new SingletonInnerClass(); } public static SingletonInnerClass getInstance(){ return Singleton.singletonInnerClass; } } 第一次看这个类的时候,没有想明白为什么不直接在外部声明一个静态变量,现在想想应该是外部类SingletonInnerClass{.language-plaintext .highlighter-rouge}初始化的时候会把静态变量全都完成初始化,这样就不能实现延迟加载(只有真正用的时候才加载).\n三 : 双重锁单例 这种模式最麻烦,而且注意点比较多\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class SingletonDCL { private volatile static SingletonDCL singletonDCL; private SingletonDCL(){ } public static SingletonDCL getSingletonDCL(){ //判断空是因为singletonDCL初始化完成之后,不用每次都加锁,从而提高性能 if(singletonDCL==null){ synchronized (SingletonDCL.class){ if(singletonDCL==null){ singletonDCL=new SingletonDCL(); } } } return singletonDCL; } } volatile 这个关键字作用是:禁止指令重排序优化\nsingletonDCL=new SingletonDCL();{.language-plaintext .highlighter-rouge} 这句话并不是一个原子操作.\n这句话执行的具体内容为:\n给singletonDCL分配内存 调用SingletonDCL构造函数完成初始化 使singletonDCL对象的引用指向分配的内存空间 JVM 的即时编译器中存在指令重排序的优化,不能保证第二第三步骤的执行顺序,volatile可以使得按 1-\u0026gt;2-\u0026gt;3步骤来执行\n(就写这么多吧,本博客的第一篇文章,如果以后发现有问题在修改,也欢迎在评论中指出问题,一起成长)\n","date":"2020-09-06T08:51:07+08:00","permalink":"https://chenchenfang.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"单例模式-Java设计模式"}]